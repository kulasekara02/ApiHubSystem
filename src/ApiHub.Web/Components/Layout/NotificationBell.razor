@using System.Net.Http.Json
@inject HttpClient Http
@inject NavigationManager Navigation

<div class="notification-bell position-relative" @onclick="ToggleDropdown" @onclick:stopPropagation="true">
    <button class="btn btn-link text-dark p-0 position-relative" type="button">
        <i class="bi bi-bell fs-5"></i>
        @if (unreadCount > 0)
        {
            <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger">
                @(unreadCount > 99 ? "99+" : unreadCount.ToString())
                <span class="visually-hidden">unread notifications</span>
            </span>
        }
    </button>

    @if (isOpen)
    {
        <div class="notification-dropdown position-absolute end-0 mt-2 bg-white border rounded shadow-lg"
             style="width: 350px; max-height: 400px; z-index: 1050;">
            <div class="d-flex justify-content-between align-items-center p-3 border-bottom">
                <h6 class="mb-0 fw-bold">Notifications</h6>
                @if (unreadCount > 0)
                {
                    <button class="btn btn-link btn-sm p-0 text-primary" @onclick="MarkAllAsRead" @onclick:stopPropagation="true">
                        Mark all as read
                    </button>
                }
            </div>

            <div class="notification-list" style="max-height: 300px; overflow-y: auto;">
                @if (isLoading)
                {
                    <div class="text-center p-4">
                        <div class="spinner-border spinner-border-sm text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                }
                else if (notifications == null || !notifications.Any())
                {
                    <div class="text-center p-4 text-muted">
                        <i class="bi bi-bell-slash fs-3 d-block mb-2"></i>
                        No notifications
                    </div>
                }
                else
                {
                    @foreach (var notification in notifications)
                    {
                        <div class="notification-item p-3 border-bottom @(notification.IsRead ? "" : "bg-light")"
                             @onclick="() => HandleNotificationClick(notification)"
                             @onclick:stopPropagation="true"
                             style="cursor: pointer;">
                            <div class="d-flex align-items-start">
                                <div class="notification-icon me-2">
                                    <i class="bi @GetIconClass(notification.Type) @GetIconColor(notification.Type)"></i>
                                </div>
                                <div class="flex-grow-1">
                                    <div class="d-flex justify-content-between align-items-start">
                                        <strong class="notification-title @(notification.IsRead ? "text-muted" : "")">
                                            @notification.Title
                                        </strong>
                                        <button class="btn btn-link btn-sm p-0 text-muted"
                                                @onclick="() => DeleteNotification(notification.Id)"
                                                @onclick:stopPropagation="true"
                                                title="Delete">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                    <p class="notification-message mb-1 small text-muted">
                                        @notification.Message
                                    </p>
                                    <small class="text-muted">
                                        @FormatTimeAgo(notification.CreatedAt)
                                    </small>
                                </div>
                            </div>
                        </div>
                    }
                }
            </div>

            @if (notifications != null && notifications.Any())
            {
                <div class="p-2 text-center border-top">
                    <a href="/notifications" class="btn btn-link btn-sm text-primary" @onclick="() => isOpen = false">
                        View all notifications
                    </a>
                </div>
            }
        </div>
    }
</div>

@if (isOpen)
{
    <div class="notification-backdrop position-fixed top-0 start-0 w-100 h-100"
         style="z-index: 1040;"
         @onclick="() => isOpen = false">
    </div>
}

@code {
    private bool isOpen = false;
    private bool isLoading = false;
    private int unreadCount = 0;
    private List<NotificationItem>? notifications;
    private System.Timers.Timer? refreshTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadUnreadCount();

        // Set up auto-refresh every 30 seconds
        refreshTimer = new System.Timers.Timer(30000);
        refreshTimer.Elapsed += async (sender, e) => await InvokeAsync(async () =>
        {
            await LoadUnreadCount();
            StateHasChanged();
        });
        refreshTimer.Start();
    }

    private async Task ToggleDropdown()
    {
        isOpen = !isOpen;
        if (isOpen)
        {
            await LoadNotifications();
        }
    }

    private async Task LoadUnreadCount()
    {
        try
        {
            var response = await Http.GetFromJsonAsync<UnreadCountResponse>("/api/v1/notifications/unread-count");
            unreadCount = response?.Count ?? 0;
        }
        catch
        {
            // Silently fail - user might not be authenticated
            unreadCount = 0;
        }
    }

    private async Task LoadNotifications()
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            var response = await Http.GetFromJsonAsync<NotificationsResponse>("/api/v1/notifications?pageSize=10");
            notifications = response?.Items ?? new List<NotificationItem>();
        }
        catch
        {
            notifications = new List<NotificationItem>();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task HandleNotificationClick(NotificationItem notification)
    {
        if (!notification.IsRead)
        {
            await MarkAsRead(notification.Id);
        }

        if (!string.IsNullOrEmpty(notification.ActionUrl))
        {
            isOpen = false;
            Navigation.NavigateTo(notification.ActionUrl);
        }
    }

    private async Task MarkAsRead(Guid notificationId)
    {
        try
        {
            await Http.PutAsync($"/api/v1/notifications/{notificationId}/read", null);

            var notification = notifications?.FirstOrDefault(n => n.Id == notificationId);
            if (notification != null)
            {
                notification.IsRead = true;
                unreadCount = Math.Max(0, unreadCount - 1);
                StateHasChanged();
            }
        }
        catch
        {
            // Silently fail
        }
    }

    private async Task MarkAllAsRead()
    {
        try
        {
            await Http.PutAsync("/api/v1/notifications/read-all", null);

            if (notifications != null)
            {
                foreach (var notification in notifications)
                {
                    notification.IsRead = true;
                }
            }
            unreadCount = 0;
            StateHasChanged();
        }
        catch
        {
            // Silently fail
        }
    }

    private async Task DeleteNotification(Guid notificationId)
    {
        try
        {
            await Http.DeleteAsync($"/api/v1/notifications/{notificationId}");

            var notification = notifications?.FirstOrDefault(n => n.Id == notificationId);
            if (notification != null)
            {
                if (!notification.IsRead)
                {
                    unreadCount = Math.Max(0, unreadCount - 1);
                }
                notifications?.Remove(notification);
                StateHasChanged();
            }
        }
        catch
        {
            // Silently fail
        }
    }

    private string GetIconClass(string type) => type.ToLower() switch
    {
        "success" => "bi-check-circle-fill",
        "warning" => "bi-exclamation-triangle-fill",
        "error" => "bi-x-circle-fill",
        _ => "bi-info-circle-fill"
    };

    private string GetIconColor(string type) => type.ToLower() switch
    {
        "success" => "text-success",
        "warning" => "text-warning",
        "error" => "text-danger",
        _ => "text-info"
    };

    private string FormatTimeAgo(DateTime createdAt)
    {
        var diff = DateTime.UtcNow - createdAt;

        if (diff.TotalMinutes < 1) return "Just now";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7) return $"{(int)diff.TotalDays}d ago";

        return createdAt.ToString("MMM dd");
    }

    public void Dispose()
    {
        refreshTimer?.Stop();
        refreshTimer?.Dispose();
    }

    private class NotificationItem
    {
        public Guid Id { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public string Type { get; set; } = "info";
        public string? ActionUrl { get; set; }
        public bool IsRead { get; set; }
        public DateTime CreatedAt { get; set; }
    }

    private class NotificationsResponse
    {
        public List<NotificationItem>? Items { get; set; }
        public int TotalCount { get; set; }
    }

    private class UnreadCountResponse
    {
        public int Count { get; set; }
    }
}

<style>
    .notification-bell {
        cursor: pointer;
    }

    .notification-dropdown {
        animation: fadeIn 0.15s ease-in-out;
    }

    .notification-item:hover {
        background-color: #f8f9fa !important;
    }

    .notification-title {
        font-size: 0.9rem;
        line-height: 1.3;
    }

    .notification-message {
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    @@keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
</style>
